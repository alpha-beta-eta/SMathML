#lang racket
(provide (all-defined-out))
(require "html.rkt")
(define (Math #:attr* [attr* '()] . mathml*)
  `(math ,attr* . ,mathml*))
(define (Merror #:attr* [attr* '()] . mathml*)
  `(merror ,attr* . ,mathml*))
(define (Mfrac #:attr* [attr* '()] . mathml*)
  `(mfrac ,attr* . ,mathml*))
(define (Mi #:attr* [attr* '()] . mathml*)
  `(mi ,attr* . ,mathml*))
(define (Mmultiscripts #:attr* [attr* '()] . mathml*)
  `(mmultiscripts ,attr* . ,mathml*))
(define (Mn #:attr* [attr* '()] . mathml*)
  `(mn ,attr* . ,mathml*))
(define (Mo #:attr* [attr* '()] . mathml*)
  `(mo ,attr* . ,mathml*))
(define (Mover #:attr* [attr* '()] . mathml*)
  `(mover ,attr* . ,mathml*))
(define (Mpadded #:attr* [attr* '()] . mathml*)
  `(mpadded ,attr* . ,mathml*))
(define (Mphantom #:attr* [attr* '()] . mathml*)
  `(mphantom ,attr* . ,mathml*))
(define (Mroot #:attr* [attr* '()] . mathml*)
  `(mroot ,attr* . ,mathml*))
(define (Mrow #:attr* [attr* '()] . mathml*)
  `(mrow ,attr* . ,mathml*))
(define (Ms #:attr* [attr* '()] . mathml*)
  `(ms ,attr* . ,mathml*))
(define (Mspace #:attr* [attr* '()] . mathml*)
  `(mspace ,attr* . ,mathml*))
(define (Msqrt #:attr* [attr* '()] . mathml*)
  `(msqrt ,attr* . ,mathml*))
(define (Mstyle #:attr* [attr* '()] . mathml*)
  `(mstyle ,attr* . ,mathml*))
(define (Msub #:attr* [attr* '()] . mathml*)
  `(msub ,attr* . ,mathml*))
(define (Msubsup #:attr* [attr* '()] . mathml*)
  `(msubsup ,attr* . ,mathml*))
(define (Msup #:attr* [attr* '()] . mathml*)
  `(msup ,attr* . ,mathml*))
(define (Mtable #:attr* [attr* '()] . mathml*)
  `(mtable ,attr* . ,mathml*))
(define (Mtd #:attr* [attr* '()] . mathml*)
  `(mtd ,attr* . ,mathml*))
(define (Mtext #:attr* [attr* '()] . mathml*)
  `(mtext ,attr* . ,mathml*))
(define (Mtr #:attr* [attr* '()] . mathml*)
  `(mtr ,attr* . ,mathml*))
(define (Munder #:attr* [attr* '()] . mathml*)
  `(munder ,attr* . ,mathml*))
(define (Munderover #:attr* [attr* '()] . mathml*)
  `(munderover ,attr* . ,mathml*))

(define (MathB #:attr* [attr* '()] . mathml*)
  `(math ((display "block") . ,attr*) . ,mathml*))
(define M Math)
(define MB MathB)
(define $ (Mrow))
(define ^ Msup)
(define _ Msub)
(define _^ Msubsup)
(define __ Munder)
(define ^^ Mover)
(define __^^ Munderover)
(define ~ Mfrac)
(define % Mtext)
(define $a (Mi "a"))
(define $b (Mi "b"))
(define $c (Mi "c"))
(define $d (Mi "d"))
(define $e (Mi "e"))
(define $f (Mi "f"))
(define $g (Mi "g"))
(define $h (Mi "h"))
(define $i (Mi "i"))
(define $j (Mi "j"))
(define $k (Mi "k"))
(define $l (Mi "l"))
(define $m (Mi "m"))
(define $n (Mi "n"))
(define $o (Mi "o"))
(define $p (Mi "p"))
(define $q (Mi "q"))
(define $r (Mi "r"))
(define $s (Mi "s"))
(define $t (Mi "t"))
(define $u (Mi "u"))
(define $v (Mi "v"))
(define $w (Mi "w"))
(define $x (Mi "x"))
(define $y (Mi "y"))
(define $z (Mi "z"))
(define $A (Mi "A"))
(define $B (Mi "B"))
(define $C (Mi "C"))
(define $D (Mi "D"))
(define $E (Mi "E"))
(define $F (Mi "F"))
(define $G (Mi "G"))
(define $H (Mi "H"))
(define $I (Mi "I"))
(define $J (Mi "J"))
(define $K (Mi "K"))
(define $L (Mi "L"))
(define $M (Mi "M"))
(define $N (Mi "N"))
(define $O (Mi "O"))
(define $P (Mi "P"))
(define $Q (Mi "Q"))
(define $R (Mi "R"))
(define $S (Mi "S"))
(define $T (Mi "T"))
(define $U (Mi "U"))
(define $V (Mi "V"))
(define $W (Mi "W"))
(define $X (Mi "X"))
(define $Y (Mi "Y"))
(define $Z (Mi "Z"))
(define $aa (Mi "&aopf;"))
(define $bb (Mi "&bopf;"))
(define $cc (Mi "&copf;"))
(define $dd (Mi "&dopf;"))
(define $ee (Mi "&eopf;"))
(define $ff (Mi "&fopf;"))
(define $gg (Mi "&gopf;"))
(define $hh (Mi "&hopf;"))
(define $ii (Mi "&iopf;"))
(define $jj (Mi "&jopf;"))
(define $kk (Mi "&kopf;"))
(define $ll (Mi "&lopf;"))
(define $mm (Mi "&mopf;"))
(define $nn (Mi "&nopf;"))
(define $oo (Mi "&oopf;"))
(define $pp (Mi "&popf;"))
(define $qq (Mi "&qopf;"))
(define $rr (Mi "&ropf;"))
(define $ss (Mi "&sopf;"))
(define $tt (Mi "&topf;"))
(define $uu (Mi "&uopf;"))
(define $vv (Mi "&vopf;"))
(define $ww (Mi "&wopf;"))
(define $xx (Mi "&xopf;"))
(define $yy (Mi "&yopf;"))
(define $zz (Mi "&zopf;"))
(define $AA (Mi "&Aopf;"))
(define $BB (Mi "&Bopf;"))
(define $CC (Mi "&Copf;"))
(define $DD (Mi "&Dopf;"))
(define $EE (Mi "&Eopf;"))
(define $FF (Mi "&Fopf;"))
(define $GG (Mi "&Gopf;"))
(define $HH (Mi "&Hopf;"))
(define $II (Mi "&Iopf;"))
(define $JJ (Mi "&Jopf;"))
(define $KK (Mi "&Kopf;"))
(define $LL (Mi "&Lopf;"))
(define $MM (Mi "&Mopf;"))
(define $NN (Mi "&Nopf;"))
(define $OO (Mi "&Oopf;"))
(define $PP (Mi "&Popf;"))
(define $QQ (Mi "&Qopf;"))
(define $RR (Mi "&Ropf;"))
(define $SS (Mi "&Sopf;"))
(define $TT (Mi "&Topf;"))
(define $UU (Mi "&Uopf;"))
(define $VV (Mi "&Vopf;"))
(define $WW (Mi "&Wopf;"))
(define $XX (Mi "&Xopf;"))
(define $YY (Mi "&Yopf;"))
(define $ZZ (Mi "&Zopf;"))
(define $aaa (Mi "&afr;"))
(define $bbb (Mi "&bfr;"))
(define $ccc (Mi "&cfr;"))
(define $ddd (Mi "&dfr;"))
(define $eee (Mi "&efr;"))
(define $fff (Mi "&ffr;"))
(define $ggg (Mi "&gfr;"))
(define $hhh (Mi "&hfr;"))
(define $iii (Mi "&ifr;"))
(define $jjj (Mi "&jfr;"))
(define $kkk (Mi "&kfr;"))
(define $lll (Mi "&lfr;"))
(define $mmm (Mi "&mfr;"))
(define $nnn (Mi "&nfr;"))
(define $ooo (Mi "&ofr;"))
(define $ppp (Mi "&pfr;"))
(define $qqq (Mi "&qfr;"))
(define $rrr (Mi "&rfr;"))
(define $sss (Mi "&sfr;"))
(define $ttt (Mi "&tfr;"))
(define $uuu (Mi "&ufr;"))
(define $vvv (Mi "&vfr;"))
(define $www (Mi "&wfr;"))
(define $xxx (Mi "&xfr;"))
(define $yyy (Mi "&yfr;"))
(define $zzz (Mi "&zfr;"))
(define $AAA (Mi "&Afr;"))
(define $BBB (Mi "&Bfr;"))
(define $CCC (Mi "&Cfr;"))
(define $DDD (Mi "&Dfr;"))
(define $EEE (Mi "&Efr;"))
(define $FFF (Mi "&Ffr;"))
(define $GGG (Mi "&Gfr;"))
(define $HHH (Mi "&Hfr;"))
(define $III (Mi "&Ifr;"))
(define $JJJ (Mi "&Jfr;"))
(define $KKK (Mi "&Kfr;"))
(define $LLL (Mi "&Lfr;"))
(define $MMM (Mi "&Mfr;"))
(define $NNN (Mi "&Nfr;"))
(define $OOO (Mi "&Ofr;"))
(define $PPP (Mi "&Pfr;"))
(define $QQQ (Mi "&Qfr;"))
(define $RRR (Mi "&Rfr;"))
(define $SSS (Mi "&Sfr;"))
(define $TTT (Mi "&Tfr;"))
(define $UUU (Mi "&Ufr;"))
(define $VVV (Mi "&Vfr;"))
(define $WWW (Mi "&Wfr;"))
(define $XXX (Mi "&Xfr;"))
(define $YYY (Mi "&Yfr;"))
(define $ZZZ (Mi "&Zfr;"))
(define $aaaa (Mi "&ascr;"))
(define $bbbb (Mi "&bscr;"))
(define $cccc (Mi "&cscr;"))
(define $dddd (Mi "&dscr;"))
(define $eeee (Mi "&escr;"))
(define $ffff (Mi "&fscr;"))
(define $gggg (Mi "&gscr;"))
(define $hhhh (Mi "&hscr;"))
(define $iiii (Mi "&iscr;"))
(define $jjjj (Mi "&jscr;"))
(define $kkkk (Mi "&kscr;"))
(define $llll (Mi "&lscr;"))
(define $mmmm (Mi "&mscr;"))
(define $nnnn (Mi "&nscr;"))
(define $oooo (Mi "&oscr;"))
(define $pppp (Mi "&pscr;"))
(define $qqqq (Mi "&qscr;"))
(define $rrrr (Mi "&rscr;"))
(define $ssss (Mi "&sscr;"))
(define $tttt (Mi "&tscr;"))
(define $uuuu (Mi "&uscr;"))
(define $vvvv (Mi "&vscr;"))
(define $wwww (Mi "&wscr;"))
(define $xxxx (Mi "&xscr;"))
(define $yyyy (Mi "&yscr;"))
(define $zzzz (Mi "&zscr;"))
(define $AAAA (Mi "&Ascr;"))
(define $BBBB (Mi "&Bscr;"))
(define $CCCC (Mi "&Cscr;"))
(define $DDDD (Mi "&Dscr;"))
(define $EEEE (Mi "&Escr;"))
(define $FFFF (Mi "&Fscr;"))
(define $GGGG (Mi "&Gscr;"))
(define $HHHH (Mi "&Hscr;"))
(define $IIII (Mi "&Iscr;"))
(define $JJJJ (Mi "&Jscr;"))
(define $KKKK (Mi "&Kscr;"))
(define $LLLL (Mi "&Lscr;"))
(define $MMMM (Mi "&Mscr;"))
(define $NNNN (Mi "&Nscr;"))
(define $OOOO (Mi "&Oscr;"))
(define $PPPP (Mi "&Pscr;"))
(define $QQQQ (Mi "&Qscr;"))
(define $RRRR (Mi "&Rscr;"))
(define $SSSS (Mi "&Sscr;"))
(define $TTTT (Mi "&Tscr;"))
(define $UUUU (Mi "&Uscr;"))
(define $VVVV (Mi "&Vscr;"))
(define $WWWW (Mi "&Wscr;"))
(define $XXXX (Mi "&Xscr;"))
(define $YYYY (Mi "&Yscr;"))
(define $ZZZZ (Mi "&Zscr;"))
(define $alpha (Mi "&alpha;"))
(define $beta (Mi "&beta;"))
(define $gamma (Mi "&gamma;"))
(define $delta (Mi "&delta;"))
(define $epsilon (Mi "&epsilon;"))
(define $zeta (Mi "&zeta;"))
(define $eta (Mi "&eta;"))
(define $theta (Mi "&theta;"))
(define $iota (Mi "&iota;"))
(define $kappa (Mi "&kappa;"))
(define $lambda (Mi "&lambda;"))
(define $mu (Mi "&mu;"))
(define $nu (Mi "&nu;"))
(define $xi (Mi "&xi;"))
(define $omicron (Mi "&omicron;"))
(define $pi (Mi "&pi;"))
(define $rho (Mi "&rho;"))
(define $sigma (Mi "&sigma;"))
(define $tau (Mi "&tau;"))
(define $upsilon (Mi "&upsilon;"))
(define $phi (Mi "&phi;"))
(define $chi (Mi "&chi;"))
(define $psi (Mi "&psi;"))
(define $omega (Mi "&omega;"))
(define $Alpha (Mi "&Alpha;"))
(define $Beta (Mi "&Beta;"))
(define $Gamma (Mi "&Gamma;"))
(define $Delta (Mi "&Delta;"))
(define $Epsilon (Mi "&Epsilon;"))
(define $Zeta (Mi "&Zeta;"))
(define $Eta (Mi "&Eta;"))
(define $Theta (Mi "&Theta;"))
(define $Iota (Mi "&Iota;"))
(define $Kappa (Mi "&Kappa;"))
(define $Lambda (Mi "&Lambda;"))
(define $Mu (Mi "&Mu;"))
(define $Nu (Mi "&Nu;"))
(define $Xi (Mi "&Xi;"))
(define $Omicron (Mi "&Omicron;"))
(define $Pi (Mi "&Pi;"))
(define $Rho (Mi "&Rho;"))
(define $Sigma (Mi "&Sigma;"))
(define $Tau (Mi "&Tau;"))
(define $Upsilon (Mi "&Upsilon;"))
(define $Phi (Mi "&Phi;"))
(define $Chi (Mi "&Chi;"))
(define $Psi (Mi "&Psi;"))
(define $Omega (Mi "&Omega;"))
(define $0 (Mn "0"))
(define $1 (Mn "1"))
(define $2 (Mn "2"))
(define $3 (Mn "3"))
(define $4 (Mn "4"))
(define $5 (Mn "5"))
(define $6 (Mn "6"))
(define $7 (Mn "7"))
(define $8 (Mn "8"))
(define $9 (Mn "9"))
(define $= (Mo "="))
(define $:= (Mo "&colone;"))
(define $!= (Mo "&ne;"))
(define $< (Mo "&lt;"))
(define $> (Mo ">"))
(define $<= (Mo "&le;"))
(define $>= (Mo "&ge;"))
(define $+ (Mo "+"))
(define $- (Mo "&minus;"))
(define $+- (Mo "&plusmn;"))
(define $-+ (Mo "&mnplus;"))
(define $* (Mo "&#8270;"))
(define $i* (Mo "&it;"))
(define $d* (Mo "&sdot;"))
(define $c* (Mo "&times;"))
(define $cm (Mo ","))
(define $inf (Mi "&infin;"))
(define $loz (Mi "&loz;"))
(define $empty (Mi "&empty;"))
(define $union (Mo "&cup;"))
(define $Union (Mo "&bigcup;"))
(define $cap (Mo "&cap;"))
(define $Cap (Mo "&bigcap;"))
(define $prime (Mo "&prime;"))
(define $af (Mo "&af;"))
(define $-> (Mo "&rarr;"))
(define $->0
  (Mo "&rarr;" #:attr* '((lspace "0") (rspace "0"))))
(define $\|-> (Mo "&mapsto;"))
(define $<=> (Mo "&hArr;"))
(define $part (Mi "&part;"))
(define $compose (Mo "&compfn;"))
(define $..h (Mo "&hellip;"))
(define $..v (Mo "&vellip;"))
(define $..c (Mo "&ctdot;"))
(define $..u (Mo "&utdot;"))
(define $..d (Mo "&dtdot;"))
(define $OverBar (Mo "&OverBar;"))
(define $conj (Mo "&and;"))
(define $disj (Mo "&or;"))
(define $neg (Mo "&not;"))
(define $int (Mo "&int;"))
(define $in (Mo "&in;"))
(define $!in (Mo "&notin;"))
(define $sube (Mo "&sube;"))
(define $sub (Mo "&sub;"))
(define $supe (Mo "&supe;"))
(define $sup (Mo "&sup;"))
(define $lp (Mo "("))
(define $rp (Mo ")"))
(define $lp0
  (Mo "(" #:attr* '((stretchy "false"))))
(define $rp0
  (Mo ")" #:attr* '((stretchy "false"))))
(define $lb (Mo "["))
(define $rb (Mo "]"))
(define $lb0
  (Mo "[" #:attr* '((stretchy "false"))))
(define $rb0
  (Mo "]" #:attr* '((stretchy "false"))))
(define $lc (Mo "{"))
(define $rc (Mo "}"))
(define $lc0
  (Mo "{" #:attr* '((stretchy "false"))))
(define $rc0
  (Mo "}" #:attr* '((stretchy "false"))))
(define $lv (Mo "|"))
(define $rv (Mo "|"))
(define $lv0
  (Mo "|" #:attr* '((stretchy "false"))))
(define $rv0
  (Mo "|" #:attr* '((stretchy "false"))))
(define $la (Mo "&lang;"))
(define $ra (Mo "&rang;"))
(define $la0
  (Mo "&lang;" #:attr* '((stretchy "false"))))
(define $ra0
  (Mo "&rang;" #:attr* '((stretchy "false"))))
(define $ld (Mo "&Vert;"))
(define $rd (Mo "&Vert;"))
(define $ld0
  (Mo "&Vert;" #:attr* '((stretchy "false"))))
(define $rd0
  (Mo "&Vert;" #:attr* '((stretchy "false"))))
(define (: . x*)
  (cond
    ((null? x*) $)
    ((null? (cdr x*)) (car x*))
    (else (apply Mrow x*))))
(define (ap f x)
  (Mrow f $af x))
(define (app f . x*)
  (ap f (apply @ x*)))
(define (appl f . x*)
  (ap f (apply tu0 x*)))
(define ((make-op op n u) . x*)
  (cond
    ((null? x*) (n))
    ((null? (cdr x*)) (u (car x*)))
    (else
     (let iter ((x (car x*)) (x* (cdr x*)) (r '()))
       (if (null? x*)
           (apply Mrow (reverse (cons x r)))
           (iter (car x*)
                 (cdr x*)
                 (cons op (cons x r))))))))
(define (err0 id)
  (lambda ()
    (error id "")))
(define (err1 id)
  (lambda (x)
    (error id "~s" x)))
(define (make-infix op id)
  (make-op op
    (err0 id)
    (err1 id)))
(define-syntax define-infix*
  (syntax-rules ()
    ((_ (id op) ...)
     (begin
       (define id (make-infix op 'id))
       ...))))
(define &cm
  (make-op $cm
    (lambda () $)
    (lambda (x) x)))
(define &+
  (make-op $+
    (err0 '&+)
    (lambda (x) (Mrow $+ x))))
(define &-
  (make-op $-
    (err0 '&-)
    (lambda (x) (Mrow $- x))))
(define $-1 (&- $1))
(define $-2 (&- $2))
(define $-3 (&- $3))
(define $-4 (&- $4))
(define $-5 (&- $5))
(define $-6 (&- $6))
(define $-7 (&- $7))
(define $-8 (&- $8))
(define $-9 (&- $9))
(define &+-
  (make-op $+-
    (lambda () (err0 '&+-))
    (lambda (x) (Mrow $+- x))))
(define &-+
  (make-op $-+
    (lambda () (err0 '&-+))
    (lambda (x) (Mrow $-+ x))))
(define &*
  (make-op $*
    (lambda () (err0 '&*))
    (lambda (x) (Msup x $*))))
(define $oplus
  (Mo "&oplus;"))
(define-infix*
  (&cap $cap)
  (&oplus $oplus)
  (&i* $i*) (&d* $d*) (&c* $c*)
  (&= $=) (&:= $:=) (&!= $!=)
  (&< $<) (&> $>)
  (&<= $<=) (&>= $>=) (&-> $->)
  (&in $in) (&sube $sube) (&sub $sub)
  (&supe $supe) (&sup $sup)
  (&union $union)
  (&<=> $<=>)
  (&compose $compose)
  (&\|-> $\|->))
(define (pare x)
  (Mrow $lp x $rp))
(define (par0 x)
  (Mrow $lp0 x $rp0))
(define (@ . x*)
  (par0 (apply : x*)))
(define (brac x)
  (Mrow $lb x $rb))
(define (bra0 x)
  (Mrow $lb0 x $rb0))
(define (curb x)
  (Mrow $lc x $rc))
(define (cur0 x)
  (Mrow $lc0 x $rc0))
(define (vert x)
  (Mrow $lv x $rv))
(define (ver0 x)
  (Mrow $lv0 x $rv0))
(define (angb x)
  (Mrow $la x $ra))
(define (ang0 x)
  (Mrow $la0 x $ra0))
(define (dver x)
  (Mrow $ld x $rd))
(define (dve0 x)
  (Mrow $ld0 x $rd0))
(define (comb a b)
  (pare
   (Mfrac #:attr* '((linethickness "0"))
          a b)))
(define (&fact n)
  (Mrow n (Mo "!")))
(define (&abs x) (ver0 x))
(define (inner* a b)
  (ang0
   (Mrow a
         (Mo "|" #:attr* '((lspace "0") (rspace "0")))
         b)))
(define (&norm x) (dve0 x))
(define (lim x a e)
  (Mrow (Munder (Mo "lim")
                (Mrow x $->0 a))
        e))
(define $sum (Mo "&sum;"))
(define $prod (Mo "&prod;"))
(define (make-bigop op)
  (case-lambda
    ((u o e) (Mrow (Munderover op u o) e))
    ((u e) (Mrow (Munder op u) e))
    ((e) (Mrow op e))))
(define-syntax define-bigop*
  (syntax-rules ()
    ((_ (id op) ...)
     (begin
       (define id (make-bigop op))
       ...))))
(define-bigop*
  (sum $sum)
  (prod $prod)
  (Union $Union)
  (Cup $Union)
  (Intersect $Cap)
  (Cap $Cap)
  
  )
(define (integral a b e x)
  (Mrow (_^ $int a b) e
        ;(Mi "d" #:attr* '((mathvariant "normal")))
        (Mo "d" #:attr* '((rspace "0")))
        x))
(define (OverBar x)
  (Mover x $OverBar))
(define (ctrans A)
  (^ A (Mo "*")))
(define (&tr A)
  (ap (Mi "tr") (par0 A)))
(define (func f A B)
  (Mrow f (Mo ":") (&-> A B)))
;This is a recommended practice from MathML standard.
(define (&prime x)
  (Msup x $prime))
(define (&!in x y)
  (Mrow x $!in y))
(define $/
  (Mo "/" #:attr* '((lspace "0") (rspace "0"))))
(define (&/ x y)
  (Mrow x $/ y))
(define (inv x)
  (^ x $-1))
(define (Re x)
  (ap (Mi "Re") x))
(define (Im x)
  (ap (Mi "Im") x))
(define (&table l)
  (apply Mtable
         (map (lambda (r)
                (apply Mtr (map Mtd r)))
              l)))
(define-syntax &Table
  (syntax-rules ()
    ((_ (x ...) ...)
     (&table (list (list x ...) ...)))))
(define (choice l)
  (Mrow $lc (&table l)))
(define-syntax Choice
  (syntax-rules ()
    ((_ (x ...) ...)
     (choice (list (list x ...) ...)))))
(define (choice0 l)
  (Mrow
   $lc
   (keyword-apply
    Mtable
    '(#:attr*) '(((displaystyle "true")))
    (map (lambda (r)
           (Mtr (Mtd (car r))
                (keyword-apply
                 Mtd '(#:attr*) '(((columnalign "left")))
                 (cdr r))))
         l))))
(define-syntax Choice0
  (syntax-rules ()
    ((_ (x ...) ...)
     (choice0 (list (list x ...) ...)))))
(define (mat l)
  (brac (&table l)))
(define-syntax Mat
  (syntax-rules ()
    ((_ (x ...) ...)
     (mat (list (list x ...) ...)))))
(define (ma0 l)
  (pare (&table l)))
(define-syntax Ma0
  (syntax-rules ()
    ((_ (x ...) ...)
     (ma0 (list (list x ...) ...)))))
(define (det l)
  (vert (&table l)))
(define-syntax Det
  (syntax-rules ()
    ((_ (x ...) ...)
     (det (list (list x ...) ...)))))
#;
(define (deriv x y . z*)
  (keyword-apply
   Mtable
   '(#:attr*) '(((displaystyle "true")))
   (cons (Mtr (Mtd x) (Mtd $=) (Mtd #:attr* '((columnalign "left")) y))
         (map (lambda (z)
                (Mtr (Mtd $) (Mtd $=)
                     (Mtd #:attr* '((columnalign "left")) z)))
              z*))))
(define (make-row . x*)
  (apply Mtr (map Mtd x*)))
(define (deriv x y . z*)
  (keyword-apply
   Mtable
   '(#:attr*) '(((displaystyle "true") (columnalign "right center left")))
   (cons (make-row x $= y)
         (map (lambda (z) (make-row $ $= z)) z*))))
(define (deriv0 x -> y . z*)
  (keyword-apply
   Mtable
   '(#:attr*) '(((displaystyle "true") (columnalign "right center left")))
   (cons (make-row x -> y)
         (map2 (lambda (-> w) (make-row $ -> w)) z*))))
(define (tup . x*)
  (pare (apply &cm x*)))
(define (tu0 . x*)
  (par0 (apply &cm x*)))
(define (lis . x*)
  (brac (apply &cm x*)))
(define (li0 . x*)
  (bra0 (apply &cm x*)))
(define (enu . x*)
  (curb (apply &cm x*)))
(define (en0 . x*)
  (cur0 (apply &cm x*)))
(define (setI a b)
  (cur0 (Mrow a $lv0 b)))
(define setE en0)
(define ((definition #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "definition")))
   (B (format "定义~a." n)) " " x*))
(define ((lemma #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "lemma")))
   (B (format "引理~a." n)) " " x*))
(define ((theorem #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "theorem")))
   (B (format "定理~a." n)) " " x*))
(define ((corollary #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "corollary")))
   (B (format "推论~a." n)) " " x*))
(define ((example #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "example")))
   (B (format "例子~a." n)) " " x*))
(define ((notation #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "notation")))
   (B (format "记号~a." n)) " " x*))
(define ((comment #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "comment")))
   (B (format "注记~a." n)) " " x*))
(define ((program #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "program")))
   (B (format "程序~a." n)) " " x*))
(define ((exercise #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "exercise")))
   (B (format "练习~a." n)) " " x*))
(define $FilledSmallSquare
  (Mo "&FilledSmallSquare;"))
(define $EmptySmallSquare
  (Mo "&EmptySmallSquare;"))
(define Q.E.D.
  (Div $EmptySmallSquare #:attr* '((class "qed"))))
(define ((proof #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "proof")))
   (B (format "证明~a." n)) " " `(,@x* ,Q.E.D.)))
(define ((proposition #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "proposition")))
   (B (format "命题~a." n)) " " x*))
(define ((remark #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "remark")))
   (B (format "评注~a." n)) " " x*))
(define ((convention #:n [n ""]) . x*)
  (keyword-apply
   Div '(#:attr*) '(((class "convention")))
   (B (format "约定~a." n)) " " x*))
(define (disR a b c)
  (&= (&i* a (@ (&+ b c)))
      (&+ (&i* a b)
          (&i* a c))))
(define (disL a b c)
  (&= (&i* (@ (&+ a b)) c)
      (&+ (&i* a c)
          (&i* b c))))
(define (assoc* a b c)
  (&= (&i* a (@ (&i* b c)))
      (&i* (@ (&i* a b)) c)))
(define (assoc+ a b c)
  (&= (&+ a (@ (&+ b c)))
      (&+ (@ (&+ a b)) c)))
(define (commute* a b)
  (&= (&i* a b) (&i* b a)))
(define (commute+ a b)
  (&= (&+ a b) (&+ b a)))
(define (&space n)
  (Mspace #:attr* `((width ,(format "~sex" n)))))
(define (ap* M . M*)
  (if (null? M*)
      M
      (apply ap* (ap M (car M*)) (cdr M*))))
(define $ldb (Mo "&LeftDoubleBracket;"))
(define $rdb (Mo "&RightDoubleBracket;"))
(define (&db x)
  (Mrow $ldb x $rdb))
(define $ldb0 (Mo "&LeftDoubleBracket;" #:attr* '((stretchy "false"))))
(define $rdb0 (Mo "&RightDoubleBracket;" #:attr* '((stretchy "false"))))
(define (&db0 x)
  (Mrow $ldb0 x $rdb0))
(define $bottom (Mi "&bottom;"))
(define (commute & a b)
  (&= (& a b) (& b a)))
(define (associate & a b c)
  (&= (& (@ (& a b)) c) (& a (@ (& b c)))))
(define (distributeL a + b * c)
  (&= (* (@ (+ a b)) c)
      (+ (@ (* a c)) (@ (* b c)))))
(define (tupan . x*)
  (angb (apply &cm x*)))
(define (tupa0 . x*)
  (ang0 (apply &cm x*)))
(define (powset A)
  (app $PPPP A))
(define $entailL (Mo "&vdash;"))
(define $entailS (Mo "&vDash;"))
(define (&entailL a b)
  (Mrow a $entailL b))
(define (&entailS a b)
  (Mrow a $entailS b))
(define $!entailS (Mo "&nvDash;"))
(define (&!entailS a b)
  (Mrow a $!entailS b))
(define i.Vdash (Mi "&Vdash;"))
(define $Vdash (Mo "&Vdash;"))
(define (&Vdash a b)
  (Mrow a $Vdash b))
(define i.cup (Mi "&cup;"))
(define i.cap (Mi "&cap;"))
(define $nVdash (Mo "&nVdash;"))
(define (&nVdash a b)
  (Mrow a $nVdash b))
(define (&neg x)
  (Mrow $neg x))
(define (@ap f x)
  (@ (ap f x)))
(define (@ap* M . M*)
  (if (null? M*)
      M
      (apply @ap* (@ap M (car M*))
             (cdr M*))))
(define (&split n)
  (make-op (&space n)
    (lambda () $)
    (lambda (x) x)))
(define $sharp (Mi "&sharp;"))
(define $::= (Mo "&Colone;"))
(define $Prime (Mo "&Prime;"))
(define (&Prime x)
  (Msup x $Prime))
(define (&rule #:space [n 8] . j*)
  (let-values (((j* j1) (split-at-right j* 1)))
    (if (null? j*)
        (car j1)
        (~ #:attr* '((displaystyle "true"))
           (apply (&split n) j*) (car j1)))))
(define (&rule* j . j*)
  (if (null? j*)
      j
      (apply &rule*
             (~ #:attr* '((displaystyle "true"))
                j (car j*))
             (cdr j*))))
(define $top (Mi "&top;"))
(define (@+ x . x*)
  (@ (apply &+ x x*)))
(define (@- x . x*)
  (@ (apply &- x x*)))
(define (@i* . x*)
  (@ (apply &i* x*)))
(define (mref A i j)
  (_ A (&cm i j)))
(define $: (Mo ":"))
(define $t* (Mo "&CircleTimes;"))
(define $w* (Mo "&wedge;"))
(define $\; (Mo ";"))
(define $equiv (Mo "&equiv;"))
(define $max (Mi "max"))
(define (@lize &) (compose @ &))
(define-syntax define-@lized-op*
  (syntax-rules ()
    ((_ (id op) ...)
     (begin
       (define id (@lize op))
       ...))))
(define (&assoc & a b c)
  (&= (& (@ (& a b)) c)
      (& a (@ (& b c)))))
(define (∈ . arg*)
  (let-values (((x* A*) (split-at-right arg* 1)))
    (let ((A (car A*)))
      (&in (apply &cm x*) A))))
(define (&Cap a b e)
  (Mrow (__^^ $Cap a b) e))
(define (&max . x*)
  (apply appl $max x*))
(define (setEnum a b)
  (setE a $..h b))
(define $->-> (Mo "&rrarr;"))
(define $@-> (Mo "&rarrhk;"))
(define $<- (Mo "&larr;"))
(define $->> (Mo "&Rarr;"))
(define $>-> (Mo "&rarrtl;"))
(define $! (Mi "!"))
(define $=> (Mo "&Implies;"))
(define $forall (Mo "&forall;"))
(define $exist (Mo "&exist;"))
(define $exists $exist)
(define-infix*
  (&\; $\;)
  (&equiv $equiv)
  (&t* $t*)
  (&: $:)
  (&->> $->>)
  (&>-> $>->)
  (&->-> $->->)
  (&@-> $@->)
  
  )
(define (func:def f A B x fx)
  (&: f (&cm (&-> A B) (&\|-> x fx))))
