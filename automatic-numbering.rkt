#lang racket
(provide (all-defined-out))
(require "match.rkt" "slt.rkt" "html.rkt")
;<entry> ::= (<%entry> (<attr>*) <xml>*)
(define (%entry? x)
  (and (vector? x) (= (vector-length x) 9) (eq? (vector-ref x 0) '%entry)))
(define (make-%entry local? class id auto? section index present cite)
  (vector '%entry local? class id auto? section index present cite))
(define (%entry-local? %entry) (vector-ref %entry 1))
(define (%entry-class %entry) (vector-ref %entry 2))
(define (%entry-id %entry) (vector-ref %entry 3))
(define (%entry-auto? %entry) (vector-ref %entry 4))
(define (%entry-section %entry) (vector-ref %entry 5))
(define (%entry-index %entry) (vector-ref %entry 6))
(define (%entry-present %entry) (vector-ref %entry 7))
(define (%entry-cite %entry) (vector-ref %entry 8))
(define (set-%entry-local?! %entry local?) (vector-set! %entry 1 local?))
(define (set-%entry-class! %entry class) (vector-set! %entry 2 class))
(define (set-%entry-id! %entry id) (vector-set! %entry 3 id))
(define (set-%entry-auto?! %entry auto?) (vector-set! %entry 4 auto?))
(define (set-%entry-section! %entry section) (vector-set! %entry 5 section))
(define (set-%entry-index! %entry index) (vector-set! %entry 6 index))
(define (set-%entry-present! %entry present) (vector-set! %entry 7 present))
(define (set-%entry-cite! %entry cite) (vector-set! %entry 8 cite))
(define (build-%entry #:local? [local? #t] #:class [class #f] #:id [id #f] #:auto? [auto? #t]
                      #:section [section #f] #:index [index #f] #:present [present default-entry-present]
                      #:cite [cite default-entry-cite])
  (make-%entry local? class id auto? section index present cite))
(define (default-entry-present %entry attr* . xml*)
  (define class (%entry-class %entry))
  (define id (%entry-id %entry))
  `(div ,(attr*-set attr* 'class class 'id id) . ,xml*))
(define (default-entry-cite %entry)
  (define id (%entry-id %entry))
  (define href (string-append "#" id))
  `(a ((href ,href)) ,id))
;<heading> ::= (<%heading> (<attr>*) <xml>*)
(define (%heading? x)
  (and (vector? x) (= (vector-length x) 8) (eq? (vector-ref x 0) '%heading)))
(define (make-%heading level id auto? section present cite switch?)
  (vector '%heading level id auto? section present cite switch?))
(define (%heading-level %heading) (vector-ref %heading 1))
(define (%heading-id %heading) (vector-ref %heading 2))
(define (%heading-auto? %heading) (vector-ref %heading 3))
(define (%heading-section %heading) (vector-ref %heading 4))
(define (%heading-present %heading) (vector-ref %heading 5))
(define (%heading-cite %heading) (vector-ref %heading 6))
(define (%heading-switch? %heading) (vector-ref %heading 7))
(define (set-%heading-level! %heading level) (vector-set! %heading 1 level))
(define (set-%heading-id! %heading id) (vector-set! %heading 2 id))
(define (set-%heading-auto?! %heading auto?) (vector-set! %heading 3 auto?))
(define (set-%heading-section! %heading section) (vector-set! %heading 4 section))
(define (set-%heading-present! %heading present) (vector-set! %heading 5 present))
(define (set-%heading-cite! %heading cite) (vector-set! %heading 6 cite))
(define (set-%heading-switch?! %heading switch?)
  (vector-set! %heading 7 switch?))
(define (build-%heading #:level [level 1] #:id [id #f] #:auto? [auto? #t] #:section [section #f]
                        #:present [present default-heading-present]
                        #:cite [cite default-heading-cite]
                        #:switch? [switch? #t])
  (make-%heading level id auto? section present cite switch?))
(define (default-heading-present %heading attr* . xml*)
  (define level (%heading-level %heading))
  (define id (%heading-id %heading))
  (if (<= level 6)
      (let ((tag (string->symbol (format "h~s" level))))
        `(,tag ,(attr*-set attr* 'id id) . ,xml*))
      (let ((class (format "h~s" level)))
        `(div ,(attr*-set attr* 'class class 'id id) . ,xml*))))
(define (default-heading-cite %heading)
  (define id (%heading-id %heading))
  (define href (string-append "#" id))
  `(a ((href ,href)) ,id))
;henv auxiliaries
(define (make-compatible henv level)
  (define len (length henv))
  (define (aux henv i)
    (if (= i level)
        henv
        (aux (cons 0 henv) (add1 i))))
  (cond ((= len level) henv)
        ((> len level) (take-right henv level))
        (else (aux henv len))))
(define (henv-inc henv)
  (cons (add1 (car henv)) (cdr henv)))
(define (henv-next henv level)
  (henv-inc (make-compatible henv level)))
;g/lenv auxiliaries
(define (extend-g/lenv class index g/lenv)
  (cons (cons class (box index)) g/lenv))
(define (g/lenv-next g/lenv class)
  (define binding (assoc class g/lenv))
  (if binding
      (let* ((box0 (cdr binding))
             (nval (add1 (unbox box0))))
        (set-box! box0 nval)
        (values g/lenv nval))
      (values (extend-g/lenv class 1 g/lenv) 1)))
;pass0
(define (pass0 exp)
  (define citation-table '())
  (define (extend-table! id citation)
    (if (assoc id citation-table)
        (error 'automatic-numbering-pass0 "id conflict!")
        (set! citation-table
              (cons (cons id citation) citation-table))))
  (let iterate ((henv '(0)) (section #f) (genv '()) (lenv '()) (rest exp) (result '()))
    (if (null? rest)
        (cons citation-table (reverse result))
        (let ((current (car rest)) (rest (cdr rest)))
          (match current
            ((,tag ,attr* . ,xml*)
             (cond
               ((symbol? tag) (iterate henv section genv lenv rest (cons current result)))
               ((%heading? tag)
                (define level (%heading-level tag))
                (define id (%heading-id tag))
                (define auto? (%heading-auto? tag))
                (define present (%heading-present tag))
                (define cite (%heading-cite tag))
                (define switch? (%heading-switch? tag))
                (cond (auto? (define section (henv-next henv level))
                             (set-%heading-section! tag section)
                             (when id (extend-table! id (cite tag)))
                             (iterate section section genv
                                      (if switch? '() lenv) rest
                                      (cons (apply present tag attr* xml*) result)))
                      (else (when id (extend-table! id (cite tag)))
                            (iterate henv (%heading-section tag) genv
                                     (if switch? '() lenv) rest
                                     (cons (apply present tag attr* xml*) result)))))
               ((%entry? tag)
                (define local? (%entry-local? tag))
                (define class (%entry-class tag))
                (define id (%entry-id tag))
                (define auto? (%entry-auto? tag))
                (define present (%entry-present tag))
                (define cite (%entry-cite tag))
                (set-%entry-section! tag section)
                (cond (auto? (let-values (((g/lenv nval) (g/lenv-next (if local? lenv genv) class)))
                               (set-%entry-index! tag nval)
                               (when id (extend-table! id (cite tag)))
                               (if local?
                                   (iterate henv section genv g/lenv rest
                                            (cons (apply present tag attr* xml*) result))
                                   (iterate henv section g/lenv lenv rest
                                            (cons (apply present tag attr* xml*) result)))))
                      (else (when id (extend-table! id (cite tag)))
                            (iterate henv section genv lenv rest
                                     (cons (apply present tag attr* xml*) result)))))
               (else
                (iterate henv section genv lenv rest (cons current result)))))
            (,else (iterate henv section genv lenv rest (cons current result))))))))
;pass1
(define (Ref id) `(ref () ,id))
(define (pass1 exp)
  (define citation-table (car exp))
  (define (reify id)
    (cond ((assoc id citation-table) => cdr)
          (else (error 'pass1 "unknown id ~s" id))))
  (define Tr
    (T `((ref *preorder* ,(lambda (ref empty id) (reify id))))))
  (define xml* (cdr exp))
  (map Tr xml*))
;automatic numbering
(define numbering-style*
  `((body
     *preorder*
     ,(lambda (tag attr* . xml*)
        `(,tag ,attr* . ,(pass1 (pass0 xml*)))))))
(define Tn
  (T numbering-style*))
;other utils
(define (fenced xml*)
  (add-between
   xml* '(", ") #:splice? #t
   #:before-first '("[") #:after-last '("]")))
(define (format-section section)
  (define sec (cdr (reverse section)))
  (apply string-append
         (add-between (map number->string sec) ".")))
(define (heading-present %heading attr* . html*)
  (define level (%heading-level %heading))
  (define auto? (%heading-auto? %heading))
  (define section (%heading-section %heading))
  (define id (%heading-id %heading))
  (cond ((= level 4) `(h4 ,(attr*-set attr* 'id id)
                          ,(format "第~a小节 " (format-section section))
                          . ,html*))
        ((= level 3) `(h3 ,(attr*-set attr* 'id id)
                          ,(format "第~a节 " (format-section section))
                          . ,html*))
        ((= level 2) `(h2 ,(attr*-set attr* 'id id)
                          ,(format "第~a章 " (format-section section))
                          . ,html*))
        ((= level 1) `(h1 ,(attr*-set attr* 'id id) . ,html*))
        (else (error 'heading-present "invalid level ~s" level))))
(define (h4-present %heading attr* . html*)
  (define auto? (%heading-auto? %heading))
  (define id (%heading-id %heading))
  (if auto?
      (let ((section (%heading-section %heading)))
        `(h4 ,(attr*-set attr* 'id id)
             ,(format "第~a小节 " (format-section section))
             . ,html*))
      `(h4 ,(attr*-set attr* 'id id) . ,html*)))
(define (h3-present %heading attr* . html*)
  (define auto? (%heading-auto? %heading))
  (define id (%heading-id %heading))
  (if auto?
      (let ((section (%heading-section %heading)))
        `(h3 ,(attr*-set attr* 'id id)
             ,(format "第~a节 " (format-section section))
             . ,html*))
      `(h3 ,(attr*-set attr* 'id id) . ,html*)))
(define (h2-present %heading attr* . html*)
  (define auto? (%heading-auto? %heading))
  (define id (%heading-id %heading))
  (if auto?
      (let ((section (%heading-section %heading)))
        `(h2 ,(attr*-set attr* 'id id)
             ,(format "第~a章 " (format-section section))
             . ,html*))
      `(h2 ,(attr*-set attr* 'id id) . ,html*)))
(define (h1-present %heading attr* . html*)
  (define id (%heading-id %heading))
  `(h1 ,(attr*-set attr* 'id id) . ,html*))
(define (heading-cite %heading)
  (define id (%heading-id %heading))
  (define href (string-append "#" id))
  (define section (%heading-section %heading))
  (define level (%heading-level %heading))
  (define ref
    `(a ((href ,href)) ,(format-section section)))
  (cond ((= level 4) (Cite "第" ref "小节"))
        ((= level 3) (Cite "第" ref "节"))
        ((= level 2) (Cite "第" ref "章"))
        (else
         (error 'heading-cite "invalid level ~s" level))))
(define (H1. #:attr* [attr* '()] #:id [id #f] #:auto? [auto? #t] . html*)
  `(,(build-%heading #:present h1-present #:level 1
                     #:id id #:auto? auto?)
    ,attr* . ,html*))
(define (H2. #:attr* [attr* '()] #:id [id #f]
             #:switch? [switch? #t] #:auto? [auto? #t] . html*)
  `(,(build-%heading #:present h2-present #:cite heading-cite
                     #:level 2 #:id id #:switch? switch?
                     #:auto? auto?)
    ,attr* . ,html*))
(define (H3. #:attr* [attr* '()] #:id [id #f]
             #:switch? [switch? #t] #:auto? [auto? #t] . html*)
  `(,(build-%heading #:present h3-present #:cite heading-cite
                     #:level 3 #:id id #:switch? switch?
                     #:auto? auto?)
    ,attr* . ,html*))
(define (H4. #:attr* [attr* '()] #:id [id #f]
             #:switch? [switch? #t] #:auto? [auto? #t] . html*)
  `(,(build-%heading #:present h4-present #:cite heading-cite
                     #:level 4 #:id id #:switch? switch?
                     #:auto? auto?)
    ,attr* . ,html*))